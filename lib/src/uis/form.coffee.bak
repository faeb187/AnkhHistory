###
  UI FORM
  @AUTHOR faeb187
###
module.exports = (->

  # @REQUIRE local modules
  # @PRIVATE
  $$        = require '../helpers/dom'
  obs       = require '../helpers/obs'
  state     = require '../helpers/state'

  # @REQUIRE events
  # @PRIVATE
  fldChange = new Event 'fldChange'

  # @DESC   validate required form input
  # @PARAM  e   MAN {event} change/blur/fldChange
  # @RETURN {void}
  validate = ( e ) ->
    e.preventDefault()
    $elm = e.target
    $fld = $$.parent $elm, '.fld'

    # ADD valid/invalid class
    cns = [ 'valid', 'invalid' ]
    if $elm.checkValidity() then cns.reverse()
    $$.removeClass( $fld, cns[ 0 ]).addClass $fld, cns[ 1 ]

    return

  # @DEFINE variables
  $ui = null
  st  = null
  id  = null
  d   = document

  # @DEFINE   ui  {json}  UI variables/methods
  # @PRIVATE
  ui  =

    # @DEFINE evs {json}  custom events
    evs:

      # @DEFINE evs.step  step events
      step:

        # @DESC   updates active step
        # @PARAM  opt.id    MAN {string}  form id
        # @PARAM  opt.step  MAN {number}  step to show
        # @RETURN {void}
        set: ( opt ) ->
          opt = opt or {}
          $ui = $$ '#' + opt.id
          step= opt.step

          # MANDATORY $ui & step
          if !$ui or !step then return

          # UPDATE active step
          $$.removeClass  $$( '.step.active'                 , $ui ), 'active'
          $$.addClass     $$( '.step:nth-child(' + step + ')', $ui ), 'active'

          return

    # bind events
    # @TODO ui.evs.click format
    bind: ( e ) ->
      
      # validate form
      if e is 'validate'
        $flds = $$ 'input, textarea, select', $ui
        $$.listen $flds, 'change'     , validate
        $$.listen $flds, 'blur'       , validate
        $$.listen $flds, 'fldChange'  , validate

        # validate nonempty fields
        $flds = $$ '[required]', $ui
        $fld.dispatchEvent fldChange for $fld in $flds when $fld.value

      # XHR service requets
      if e is 'services'
        $$ = require '../helpers/dom'
        
        # zip fills city
        $zip  = $$ '#zip'
        $city = $$ '#city'
        console.log $ui

        if $zip and $city
          $$.listen $zip, 'keyup', ( e ) ->
            zip = e.target.value
            if zip.length <= 3
              $city.value = ''
              return

            $$.read 'service/city/get/?zip=' + zip, ( city ) ->
              $city.value = if city then city else ''

      if e is 'range'

        # update range text input/display on range change
        $$.listen $$( '[type=range]', $ui ), 'input', ( e ) ->
          e.target.previousSibling.value = e.target.value

        # update range thumb on text input change
        $$.listen $$( '[type=range]', $ui ).previousSibling, 'keyup', ( e ) ->
          e.target.nextSibling.value = e.target.value

      # steps navigation click
      if e is 'next'
        $$.listen $$( '.steps a:not(.badge)', $ui ), 'click', ( e ) ->
          $liC = e.currentTarget.parentNode
          if $$.hasClass $liC, 'active' then return

          e.stopPropagation()
          e.preventDefault()

          # DEFINE variables
          $steps  = $$ '.step'                  , $ui
          $act    = $$ '.step.active'           , $ui
          $stepsN = $$ '.steps'                 , $ui
          $actN   = $$ '.steps li.active'       , $ui
          $flds   = $$ '.step.active [required]', $ui
          $bdg    = $$ '.steps li.active .badge', $ui

          # GET current active index
          idx = $$.index $liC

          # SHOW badges
          iv = 0
          $fld.checkValidity() or iv++ for $fld in $flds
          $bdg.innerText = iv
          $$.css $bdg, display: if iv > 0 then 'block' else 'none'

          # UPDATE form view
          $act.className = 'step'
          $steps[ idx ].className += ' active'

          # UPDATE steps nav
          $$.removeClass $$( '.active', $stepsN ), 'active'
          $$( 'li' ,$stepsN )[ idx ].className +=  ' active'

          # UPDATE UI state
          st.activeStep = idx
          state.set id: id, state: st

      # button 'submit' click
      if e is 'submit'
        $$.listen $$( '.submit', $ui ), 'click', ->
          if !action then return

      # update UI state on input change
      if e is 'change'
        $$.listen $$( 'input, textarea, select', $ui ), 'change', ( e ) ->
          $elm  = e.target
          type  = $elm.getAttribute 'type'
          prop  = if type is 'radio' then $elm.getAttribute( 'name' ) else $elm.id
          val   = if type is 'radio' then $elm.id else $elm.value
          st[ prop ] = val
          state.set id: id, state: st

      # UPDATE UI state on window unload
      if e is 'unload' then window.onunload = ->

        # CHECK if user has changed something...
        $fld = $$ 'input:focus, textarea:focus, select:focus', $ui
        if !$fld then return

        type  = $fld.getAttribute 'type'
        prop  = if type is 'radio' then $fld.getAttribute 'name'  else $fld.id
        val   = if type is 'radio' then $fld.id                   else $fld.value

        # ...and update that change
        st[ prop ] = val
        state.set id: id, state: st

  #
  # PUBLIC
  #
  return {

    # @DESC   build new form
    # @DESC   opt.id                                        MAN {string   UI id
    # @PARAM  opt.steps                                     MAN {array}   form steps
    # @PARAM  opt.steps.$.title                             OPT {string}  lang ref
    # @PARAM  opt.steps.$.fieldsets                         OPT {array}   field groups
    # @PARAM  opt.steps.$.fieldsets.$.legend                OPT {string}  lang reference
    # @PARAM  opt.steps.$.fieldsets.$.fields                OPT {array}   form fields
    # @PARAM  opt.steps.$.fieldsets.$.fields.$.id           MAN {string}  field id
    # @PARAM  opt.steps.$.fieldsets.$.fields.$.type         OPT {string}  field type
    # @PARAM  opt.steps.$.fieldsets.$.fields.$.attrs        OPT {object}  field attributes
    # @PARAM  opt.steps.$.fieldsets.$.fields.$.label        OPT {string}  lang ref
    # @PARAM  opt.steps.$.fieldsets.$.fields.$.placeholder  OPT {string}  lang ref
    # @PARAM  opt.steps.$.fieldsets.$.fields.$.required     OPT {boolean} input validation
    # @PARAM  opt.target                                    MAN {string}  id of DOM target
    init: ( opt ) ->
      opt   = opt or {}
      id    = opt.id
      $t    = opt.target
      steps = opt.steps

      # MANDATORY id, steps & target
      if !id or !steps or !$t then return

      # MARKUP UI
      $ui           = $$ '<form/>', 'class': 'ui-form'
      $ui.id = id
      $steps        = $$ '<nav/>'         , 'class': 'steps'
      $stepsUl      = $$ '<ul/>'
      $steps.appendChild $stepsUl
      stepLen       = steps.length

      # GET UI state
      st          = state.get( id: id ) or {}
      activeStep  = st.activeStep or 0

      # HANDLE steps
      for step, stepIdx in steps
        stepId  = id + '-step-' + stepIdx
        fs      = step.fieldsets
        cn      = 'step'

        if !stepId or !fs then continue

        # STEP navigation
        ###
        if step.icon
          $li = $$ '<li/>'
          $i  = $$ '<i/>', 'class': step.icon
          $a  = $$ '<a/>'
          $bdg= $$ '<a/>', 'class': 'badge'
          $bdg.innerText = '0'

          $a.appendChild  $i
          $li.appendChild $a
          $li.appendChild $bdg
          $stepsUl.appendChild $li
          if stepIdx is activeStep then $li.className = 'active'

        ###

        # active step from localStorage
        if activeStep is stepIdx then cn += ' active'

        # step markup
        $step = $$ '<section/>', id: stepId, 'class': cn
        if step.title then $step.appendChild $$ '<h2/>', 'data-lang': step.title

        # handle fieldsets
        for f, fsIdx in fs

          # DEFINE variables
          fsId = stepId + '-fs-' + fsIdx
          flds = f.fields
          $fs   = $$ '<fieldset/>'

          # MANDATORY fieldset id & fields
          if !fsId or !flds then continue

          # APPEND fieldset legend
          if f.legend then $fs.appendChild $$ '<legend/>', 'data-lang', f.legend

          # HANDLE fields
          for fld in flds

            # DEFINE variables
            type  = fld.type or 'text'
            name  = fld.name
            $row  = $$ '<div/>' , 'class' : 'fld fld-' + name
            $ok   = $$ '<i/>'   , 'class' : 'ui-icon icon-ok ion-checkmark'
            $nok  = $$ '<i/>'   , 'class' : 'ui-icon icon-nok ion-close'
            $inf  = $$ '<i/>'   , 'class' : 'ui-icon icon-info ion-info'

            # HANDLE field types
            switch type

              # RADIO group
              when 'radio'

                $grp = $$ '<div/>', 'class': 'radio-group'

                # ADD label if available
                if fld.label
                  $lab = $$ '<label/>', 'data-lang': fld.label
                  $row.appendChild $lab

                # CHECK for UI state
                $checked = st[ name ] or null

                # ADD radio options
                for o in fld.options
                  $fld = $$ '<div/>'
                  $inp = $$ '<input/>',
                    id    : o.id
                    type  : 'radio'
                    name  : name
                    value : o.value

                  $label = $$ '<label/>', for: o.id
                  if $checked is o.id then $inp.setAttribute 'checked', true

                  if o.icon then $label.appendChild $$ '<i/>', 'class': o.icon
                  else $label.setAttribute 'data-lang', o.label

                  $fld.appendChild $inp
                  $fld.appendChild $label
                  $fld.appendChild $ok
                  $fld.appendChild $nok
                  $fld.appendChild $inf
                  $grp.appendChild $fld

                # SKIP common stuff
                $row.appendChild $grp
                $fs.appendChild $row
                continue

              # SELECT menu
              when 'select'
                # MARKUP select
                $fld  = $$ '<select/>'

                # HANDLE placeholder
                if fld.placeholder
                  $fld.appendChild $$ '<option/>',
                    'data-lang' : fld.placeholder
                    disabled    : 'disabled'
                    selected    : 'selected'

                # APPEND options
                for o in fld.options
                  $o = $$ '<option/>'
                  if      o.icon  then $o.appendChild $$ '<i/>', 'class': o.icon
                  else if o.label then $o.setAttribute 'data-lang', o.label
                  if      o.value then $o.value = o.value
                  $fld.appendChild $o

                # as some elements needs to wrap the :input
                # and we need a reference to all of the real ones...
                $input = $fld

              # TEXTAREA
              when 'textarea'
                $fld = $$ '<textarea/>'
                $input = $fld

              # RANGE
              when 'range'
                $inp  = $$ '<input/>', type: 'range', name: name
                $grp  = $$ '<div/>', 'class': 'range-group'
                $fld  = d.createDocumentFragment()
                $txt  = $$ '<input/>',
                  id    : name + '-dsp'
                  type  : 'number'
                  name  : name + '-dsp'
                  value : if st[ name ] then st[ name ] else ( fld.value or 0 )

                if fld.attrs
                  if fld.attrs.min  then $txt.setAttribute 'min'  , fld.attrs.min
                  if fld.attrs.max  then $txt.setAttribute 'max'  , fld.attrs.max
                  if fld.attrs.step then $txt.setAttribute 'step' , fld.attrs.step
                
                $grp.appendChild $txt
                $grp.appendChild $inp
                $fld.appendChild $grp
                $input = $inp
             
              # TEXT, DATE, EMAIL, PASSWORD
              else
                type = fld.type or 'text'

                $inp  = $$ '<input/>', type: type, name: name
                $fld  = d.createDocumentFragment()

                if fld.placeholder then $inp.setAttribute 'placeholder', fld.placeholder

                $fld.appendChild $inp
                $input = $inp

            # ADD field attributes and label
            if fld.attrs then $input.setAttribute k, v for k, v of fld.attrs

            if fld.label
              $label = $$ '<label/>', 'data-lang': fld.label, for: name
              $row.appendChild $label

            # REQUIRED field
            if fld.required
              $input.setAttribute 'required'      , 'required'
              $input.setAttribute 'aria-required' , 'true'
              $row.className +=   ' required'

            # SET input id
            $input.id = name

            # FILL value from UI state
            if st[ name ] then $input.value = st[ name ]

            # APPEND UI to target
            $fld.appendChild  $ok
            $fld.appendChild  $nok
            $fld.appendChild  $inf
            $row.appendChild  $fld
            $fs.appendChild   $row
          $step.appendChild $fs

        # APPEND UI to target
        $ui.appendChild $step
      #$ui.appendChild $steps
      $t.appendChild $ui

      # EVENT binding
      obs.l 'ui-form-step-set', ui.evs.step.set

      #ui.bind 'next'
      # ui.bind 'submit'
      ui.bind 'change'
      ui.bind 'unload'
      ui.bind 'services'
      ui.bind 'range'
      ui.bind 'validate'
  }
)()
